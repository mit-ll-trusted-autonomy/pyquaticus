#----------------------------------------------------------------------
# config.py -- configuration parameters for Python wrappers of MOOS-IvP
#
# originally developed at NRL and modified at MIT LL
import os
import numpy as np
import subprocess
from pathlib import Path
from pyquaticus.config import config_dict_std


pyquaticus_config_std = {
    # Game Parameters
    "max_score":           20,  # maximum score per episode (until a winner is declared)
    "max_time":         600.0,  # maximum time (seconds) per episode

    # Observation parameters
    "normalize_obs":          True,  # flag for normalizing the observation space
    "short_obs_hist_length":     1,  # number of timesteps to include for the short-term observation history
    "short_obs_hist_interval":   1,  # number of steps in between entries in the short-term observation history
    "long_obs_hist_length":      1,  # number of timesteps to include for the long-term observation history
    "long_obs_hist_interval":    4,  # number of steps in between entries in the long-term observation history

    # Global state parameters
    "normalize_state":       False,  # flag for normalizing the global state
    "short_state_hist_length":   1,  # number of timesteps to include for the short-term global state history
    "short_state_hist_interval": 1,  # number of steps in between entries in the short-term global state history
    "long_state_hist_length":    1,  # number of timesteps to include for the long-term global state history
    "long_state_hist_interval":  4,  # number of steps in between entries in the long-term global state history
}


class FieldReaderConfig:
    '''
    This configuration reads field information generated by a script.
    This format started with the jervis-2023 mission and continued with the charles-2023
    mission, both included in moos-ivp-aquaticus
    '''
    def __init__(self, mission_dir:str, script:str=f'{os.path.dirname(__file__)}/get_field.sh'):
        ####### Geometry Parameters #######
        # field reader
        print(f"Using field script: {script}")
        subprocess.call([script, mission_dir])

        f = open(f'{mission_dir}/field.txt', 'r')
        x = f.readlines()[:3]
        red_zone = []
        blue_zone = []
        for zone in x:
            pts = []
            for coord in zone.split('{')[1].split('}')[0].split(':'):
                vals = coord.split(',')
                pts.append((float(vals[0]), float(vals[1])))

            if zone[:3].lower() == "red":
                red_zone.extend(pts)
            else:
                assert zone[:4].lower() == "blue"
                blue_zone.extend(pts)

        f.close()
        f = open(f'{mission_dir}/flags.txt', 'r')
        flags = f.readlines()

        bf = []
        rf = []
        i = 0
        for flag in flags[:2]:
            if flag[:3].lower() == "red":
                rf = [float(flag.split(',')[0].split('=')[-1]), float(flag.split(',')[1].split('=')[-1].split('\"')[0])]
            else:
                assert flag[:4].lower() == "blue"
                bf = [float(flag.split(',')[0].split('=')[-1]), float(flag.split(',')[1].split('=')[-1].split('\"')[0])]
            i += 1
        f.close()

        self.blue_flag = bf
        self.red_flag = rf

        # Zone order in dumped info is clockwise from north west by default (upper left in Pyquaticus terminology)
        self.blue_zone_ul = blue_zone[0]
        self.blue_zone_ur = blue_zone[1]
        self.blue_zone_lr = blue_zone[2]
        self.blue_zone_ll = blue_zone[3]

        self.red_zone_ul = red_zone[0]
        self.red_zone_ur = red_zone[1]
        self.red_zone_lr = red_zone[2]
        self.red_zone_ll = red_zone[3]

        num_rotations = 0
        while not self._set_boundary_and_scrimmage():
            # keep rotating until the scrimmage points make sense
            self._rotate_zone_points()
            num_rotations += 1
            if num_rotations > 3:
                raise RuntimeError("Cannot figure out boundary and scrimmage lines based on zone points given (likely an orientation issue).")

        print("############### Inferred Region Configuration ##################")
        print("Blue Zone:")
        print(self.blue_zone_ur)
        print(self.blue_zone_lr)
        print(self.blue_zone_ll)
        print(self.blue_zone_ul)
        print("Red Zone:")
        print(self.red_zone_ur)
        print(self.red_zone_lr)
        print(self.red_zone_ll)
        print(self.red_zone_ul)
        print("Boundary Corners:")
        print(self.env_ur)
        print(self.env_lr)
        print(self.env_ll)
        print(self.env_ul)
        print("Scrimmage:")
        print(self.scrimmage_coords)

        # other geometry parameters
        self.flag_grab_radius = 10 #meters

        ####### Simulation Parameters #######
        self.dt = 0.1 #moostime (sec) between steps

        ####### Game Parameters #######
        self.tagging_cooldown = 60 #seconds

    def _set_boundary_and_scrimmage(self):
        """
        Sets the boundaries and scrimmage points assuming the blue_zone_* and red_zone_*
        have already been populated.

        Returns a boolean indicating success.
        """
        if (abs(self.blue_zone_ur[1] - self.red_zone_ul[1]) < 1e-2 and
            abs(self.blue_zone_ur[0] - self.red_zone_ul[0]) < 1e-2):
            print("Blue zone to the left of red zone")
            self.scrimmage_coords = [self.red_zone_ll, self.red_zone_ul]
            self.env_ul = self.blue_zone_ul
            self.env_ur = self.red_zone_ur
            self.env_ll = self.blue_zone_ll
            self.env_lr = self.red_zone_lr
            return True
        elif (abs(self.blue_zone_ul[1] - self.red_zone_ur[1]) < 1e-2 and
              abs(self.blue_zone_ul[0] - self.red_zone_ur[0]) < 1e-2):
            print("Red zone to the left of the blue zone")
            self.scrimmage_coords = [self.red_zone_lr, self.red_zone_ur]
            self.env_ul = self.red_zone_ul
            self.env_ur = self.blue_zone_ur
            self.env_ll = self.red_zone_ll
            self.env_lr = self.blue_zone_lr
            return True
        else:
            return False

    def _rotate_zone_points(self):
        """
        Rotates the zone points for red and blue zone clockwise once.
        """
        self.blue_zone_ur, self.blue_zone_lr, self.blue_zone_ll, self.blue_zone_ul = \
        self.blue_zone_ul, self.blue_zone_ur, self.blue_zone_lr, self.blue_zone_ll
        self.red_zone_ur, self.red_zone_lr, self.red_zone_ll, self.red_zone_ul = \
        self.red_zone_ul, self.red_zone_ur, self.red_zone_lr, self.red_zone_ll


# for backwards compatibility with assumed docker folder structure
class JervisBayConfig(FieldReaderConfig):
    def __init__(self):
        super(f"os.path.dirname(__file__)/../../../moos-ivp-aquaticus/missions/jervis-2023")


class MITConfig2025(FieldReaderConfig):
    def __init__(self):
        pyquaticus_root = Path(__file__).resolve().parents[2]
        super().__init__(str(pyquaticus_root / "moos" / "missions" / "charles-2025"))

        ####### Geometry Parameters #######
        self.agent_radius = 6 * [2.0]

        ####### Dynamics Parameters #######
        self.max_speeds = 6 * [2.0]